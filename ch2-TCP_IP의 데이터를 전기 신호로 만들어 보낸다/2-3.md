## Story 3. 데이터를 송수신한다

### (1) 프로토콜 스택에 HTTP 리퀘스트 메세지를 넘긴다

connect에서 애플리케이션에 제어가 되돌아오면 데이터 송수신 동작에 들어갑니다.

이 동작은 애플리케이션이 write를 호출하여 송신 데이터를 프로토콜 스택에 건네주고 프로토콜 스택이 송신 동작을 실행합니다.

여기서 몇 가지 중요한 점이 있는데, 프로토콜 스택은 받은 데이터를 곧바로 송신하는 것이 아니라 일단 자체의 내부 송신용 버퍼 메모리에 저장하고 애플리케이션이 다음 데이터를 건네주기를 기다립니다.

이는 애플리케이션이 건네주는 데이터 길이는 그때그때 다르며 프로토콜 스택에서 제어할 수 있는 것이 아니기 때문입니다.

프로토콜 스택은 MTU라는 매개변수(한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이)와 MSS라는 매개변수(헤더를 제외한 하나의 패킷으로 운반할 수 있는 데이터의 최대 길이)를 바탕으로 이를 판단합니다.

또한 타이밍을 기준으로도 판단하는데, 프로토콜 내부의 타이머는 일정 시간 이상 경과하면 MSS에 가깝게 데이터가 모이지 않더라도 패킷을 송신합니다.

위의 두 가지 요소는 상반된 면이 있습니다. 이 둘을 절충하면서 송신 동작을 실행해야 하는데, 이는 전적으로 프로토콜 스택을 만드는 개발자에게 맡겨져 있습니다. 따라서 OS나 버전에 따라 달라집니다.

이와 같이 프로토콜 스택에만 이를 맡긴다면 좋지 않으므로 애플리케이션측에서 송신 타이밍을 제어하는 여지도 남겨두었습니다. 즉, 데이터 송신을 의뢰할 때 옵션을 지정할 수 있으며 옵션을 통해 버퍼에 머물지 않고 바로 송신하도록 지정할 수도 있습니다.

### (2) 데이터가 클 때는 분할하여 보낸다

긴 데이터를 보낼 경우 한 개의 패킷에 들어가지 않을 수도 있습니다.

프로토콜 스택은 송신 버퍼에 들어있는 데이터를 차례대로 MSS 크기에 맞게 분할하고 하나씩 패킷에 넣어 송신합니다.

데이터 조각의 모습을 가늠하여 데이터 조각을 송신하면 맨 앞부분에 TCP 헤더를 부가하게 되고 이를 IP 담당 부분에 건네주어 송신 동작을 실행합니다.

### (3) ACK 번호를 사용하여 패킷이 도착했는지 확인한다.

여러 패킷의 수신 확인 방법에 대해 알아보겠습니다.

TCP 담당 부분은 데이터를 분할할 때 조각이 몇 번째 바이트에 해당하는지를 세어둡니다. 그리고 이를 TCP 헤더의 시퀀스 번호라는 항목에 기록합니다. 수신측은 패킷 전체 길이에서 헤더 길이를 뺀 데이터 크기를 계산하여 크기를 산출하고 송신 데이터가 몇 번째 바이트부터 시작되는 것인지를 알 수 있게 됩니다.

이렇게 되면 수신측에서는 패킷이 누락되었는지 확인할 수 있습니다. 수신측은 데이터를 몇 번째 바이트까지 수신한 것인지를 TCP 헤더의 ACK 번호에 기록하여 송신측에 알려줍니다. 이를 수신 확인 응답이라고 부릅니다. 만약 송신한 데이터에 대응하는 ACK 번호가 돌아오지 않으면 패킷을 다시 보내게 됩니다.

실제로는 시퀀스 번호가 1부터 시작하지 않고 난수를 바탕으로 산출한 초기값으로 시작합니다. 항상 1부터 시작한다면 거기에 악의적인 공격을 가할 우려가 있기 때문입니다. 다만, 난수로 초기값을 설정하면 몇 번이 초기값인지 알 수 없으므로 데이터 송수신 전에 초기값을 상대에게 알리게 되어 있는데, 앞서 SYN에 1을 설정할 때 시퀀스 번호를 보내는 것입니다.

반대의 경우(서버가 클라이언트에 데이터를 보내는 경우)에도 마찬가지입니다.

이처럼 TCP에 맡겨두면 오류가 발생해도 데이터가 문제 없이 상대에게 도착하므로 애플리케이션의 송신 동작은 송신한 채로 끝납니다. 즉 LAN 어댑터, 버퍼, 라우터 모두 회복 조치를 따로 취하지 않습니다. 단 도중에 케이블이 분리되거나 서버가 다운되는 등의 이유로 TCP가 아무리 다시 보내도 데이터가 도착하지 않는 경우에는 몇 번 다시 보내보고 데이터 송신 동작을 강제 종료하고 애플리케이션에 오류를 통지합니다.

### (4) 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다.

실제 오류 검출과 회복의 원리는 꽤 복잡하므로 요점만 정리하겠습니다.

우선, ACK 번호가 돌아오는 것을 기다리는 시간을 타임아웃 값이라고 합니다.

ACK 번호의 반송이 지연되도록 하는 사태는 혼잡이 원인인 경우가 많으므로 거기에 헛된 패킷을 보내면 혼잡을 악화시킬 우려가 있습니다. 그렇다고 대기 시간이 길게 되면 패킷을 다시 보내는 동작이 지연되어 속도 저하의 원인이 됩니다.

따라서 길지도 짧지도 않은 값을 설정해야 하는데, 이를 일정한 값으로 설정하면 적절하지 않은 방법이 될 수 있습니다.

따라서 ACK 번호가 돌아오는 시간을 기준으로 동적으로 변경하도록 하여 ACK 번호가 돌아오는 시간이 지연되면 이것에 대응하여 대기 시간도 늘리는 방식을 사용합니다.

### (5) 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다.

한 개의 패킷을 보내고 ACK 번호를 기다리는 방법은 단순하지만 시간 낭비일 수 있습니다. 이러한 낭비를 줄이기 위해 TCP는 윈도우 제어라는 방식에 따라 연속해서 복수의 패킷을 보내는 방식입니다.

이렇게 하면 ACK 번호를 기다리는 시간 낭비를 줄일 수 있으나 주의할 점이 있습니다.

수신측의 능력을 초과하여 패킷을 보내느 사태가 일어날 수도 있다는 것입니다.

수신측은 패킷을 버퍼 메모리에 일시 보과하였다가 연결하여 원래 데이터를 복원한 후 애플리케이션에 건네줍니다.

이러한 수신 버퍼에 데이터가 넘쳐버리게 되는 것을 말합니다.

이를 방지하기 위해서는 수신측에서 송신측에 수신 가능한 데이터 양을 통지하고 이 양을 초과하지 않도록 송신 동작을 실행해야됩니다. 이것이 바로 윈도우 제어 방식의 개념입니다.

이는 TCP 헤더의 윈도우 필드에서 조절하며,

수신측의 능력이 높아서 패킷이 도착하는 속도보다 빨리 수신 처리를 할 수 있으면 버퍼는 곧 비워지므로 이것을 윈도우 필드를 통해 통지합니다.

또한 수신 가능한 데이터 양의 최대값은 TCP 헤더의 윈도우 사이즈라는 값으로 알리게 됩니다.

### (6) ACK 번호와 윈도우를 합승한다.

송수신 동자그이 효율성을 높이기 위해 ACK 번호와 윈도우를 통지하는 타이밍을 고려해야 합니다.

이 둘을 별개로 보고 별도의 패킷으로 보내게 된다면 어떻게 될까요?

송신측에서 보낸 데이터가 수신측에 도착하여 ACK 번호를 통지하고 데이터를 애플리케이션에 건네주었을 때 윈도우를 송신측에 통지하는 상태가 될 수 있습니다. 이렇게 해서는 수신측에서 보내는 패킷이 많아져 효율성이 저하됩니다.

수신측은 ACK번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다리는데 다음 통지 동작이 일어나면 양쪽을 상승시켜서 한 개의 패킷으로 묶어서 보냅니다.

예를 들어 ACK번호의 송신을 대조할 때 윈도우 통지가 일어나면 ACK 번호와 윈도우를 한 개의 패킷에 합승시켜 통지하여 패킷의 수를 줄일 수 있습니다.

ACK번호나 윈도우 모두 연속해서 일어난 경우에 최후의 것만 통지합니다.

### (7) HTTP 응답 메세지를 수신한다

위의 동작으로 프로토콜 스택이 HTTP 리퀘스트 메세지를 보내는 일련의 동작이 끝났습니다.

이후 브라우저는 리퀘스트 메세지를 송신해 달라고 의뢰하고 이것이 끝나면 응답 메세지를 받기 위해 read 프로그램을 호출합니다.

그러면 read를 경유하여 프로토콜 스택으로 제어가 넘어가고 수신 버퍼를 사용하여 수신 데이터를 추출하여 애플리케이션에 건네주게 됩니다.

프로토콜 스택은 응답 메세지가 돌아올 때까지 수신 버퍼에서 데이터를 추출하여 애플리케이션에 건네주는 작업을 잠시 보류합니다.

이 때 프로토콜 스택이 쉬는 것이 아니라 다수의 애플리케이션에서 의뢰받은 작업을 실행합니다.
