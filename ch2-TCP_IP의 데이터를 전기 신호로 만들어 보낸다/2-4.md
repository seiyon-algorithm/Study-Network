## Story 4. 서버에서 연결을 끊어 소켓을 말소한다

### (1) 데이터 보내기를 완료했을 때 연결을 끊는다

웹에서 서버가 클라이언트의 리퀘스트에 대한 응답 메세지를 반송 완료하면 데이터 보내기가 완료되고 이 경우 서버측은 연결 끊기 단계에 들어갑니다.

이 부분은 애플리케이션에 따라 다르므로 프로토콜 스택은 어느 쪽에서 먼저 연결 끊기 단계에 들어가도 좋게 만들어져 있습니다.

만약 서버측이 연결 끊기 단계에 들어가는 것으로 간주한다면

Socket라이브러리의 close를 호출하고 프로토콜 스택은 TCP 헤더를 만들어 연결 끊기 정보를 설정합니다.

구체적으로는 컨트롤 비트의 FIN 비트를 1로 설정하고 IP 담당 부분에 의뢰하여 송신해달라고 합니다.

클라이언트는 이를 받아 ACK번호를 반송하고 애플리케이션은 read를 호출하여 데이터를 가지러 옵니다.

서버에서 보낸 데이터를 전부 수신 완료했다는 사실을 애플리케이션에게 알리고 완료되면 클라이언트도 종료합니다.

그러면 클라이언트의 애플리케이션도 close를 호출하고 FIN 비트에 1을 설정한 TCP 헤더를 만들어 IP부분에 의뢰 후 송신합니다.

그 후 서버에서 ACK 번호가 돌아오면 서버와의 대화가 끝납니다.

### (2) 소켓을 말소한다.

위의 과정이 끝난다고 하여도 바로 소켓을 말소하지 않고 잠시 기다린 후 소켓을 말소합니다.

오동작을 막기 위해 잠시 기다리는 것입니다. 이유는 다양하지만 한 가지 예시를 보면

클라이언트가 FIN을 송신하고 서버가 ACK송신, 그리고 서버가 FIN을 송신하고 클라이언트가 소켓을 말소한다면 거기에 기록되어 있던 제어 정보가 없어지므로 소켓에 할당되어 있던 포트 번호도 몇 번인지 알 수 없게 됩니다.

이 시점에서 다른 애플리케이션이 소켓을 작성하면 같은 포트 번호가 할당될 수 있습니다.

이 상태에서 서버가 다시 보낸 FIN이 도착하면 어떻게 될까요?

그래서 소켓을 즉시 말소하지 않고 기다리는 것입니다.

이때 기다리는 시간은 패킷을 다시 보내는 동작과 관계까 있습니다.

아까 패킷이 없어졌을 때 몇 번 다시 보내보고 회복 전망이 없으면 다시 보내는 동작을 멈춘다고 하였죠?

명확한 규정은 없지만 일반적으로 몇 분 정도 기다리고 나서 소켓을 말소합니다.
